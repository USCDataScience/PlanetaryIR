{
  "deepdive": {
    "calibration": {
      "holdout_fraction": 0.25
    },
    "db": {
      "default": {
        "dbname": "deepdive_planetaryIR_SnehaS",
        "driver": "org.postgresql.Driver",
        "host": "localhost",
        "incremental_mode": "ORIGINAL",
        "password": "",
        "port": "5432",
        "url": "jdbc:postgresql://localhost:5432/deepdive_planetaryIR_SnehaS",
        "user": "SnehaS"
      }
    },
    "extraction": {
      "extractors": {
        "ext_is_target": {
          "cmd": "\n\n\t# TODO use temporary table\n\tdeepdive create table \"is_target\"\n\tdeepdive sql 'INSERT INTO is_target SELECT DISTINCT R0.column_0, R0.column_1, 0 AS id, \nCASE WHEN R0.column_2 > 0 THEN true\n     WHEN R0.column_2 < 0 THEN false\n     ELSE NULL\nEND AS label\n          FROM target_label_resolved R0\n        \n          \nUNION ALL\nSELECT DISTINCT R0.mention_id, R0.mention_text, 0 AS id, (NULL :: BOOLEAN) AS label\n          FROM target_mention R0\n        \n          '\n\t# TODO rename temporary table to replace output_relation\n\t\n        ",
          "dependencies": [
            "ext_target_label_resolved",
            "ext_target_mention_by_map_target_mention"
          ],
          "input_relations": [
            "target_label_resolved",
            "target_mention"
          ],
          "output_relation": "is_target",
          "style": "cmd_extractor"
        },
        "ext_person_mention_by_map_person_mention": {
          "dependencies": [
            "ext_sentences_by_nlp_markup"
          ],
          "input": " SELECT R0.doc_id AS \"sentences.R0.doc_id\", R0.sentence_index AS \"sentences.R0.sentence_index\", R0.sentence_text AS \"sentences.R0.sentence_text\"\nFROM sentences R0\n        \n          ",
          "input_batch_size": "100000",
          "input_relations": [
            "sentences"
          ],
          "output_relation": "person_mention",
          "parallelism": "1",
          "style": "tsv_extractor",
          "udf": "\"$DEEPDIVE_APP\"/udf/map_person_mention.py"
        },
        "ext_sentences_by_nlp_markup": {
          "input": " SELECT R0.id AS \"articles.R0.id\", R0.content AS \"articles.R0.content\"\nFROM articles R0\n        \n          ",
          "input_batch_size": "100000",
          "input_relations": [
            "articles"
          ],
          "output_relation": "sentences",
          "parallelism": "1",
          "style": "tsv_extractor",
          "udf": "\"$DEEPDIVE_APP\"/udf/nlp_markup.sh"
        },
        "ext_target_feature_by_extract_target_features": {
          "dependencies": [
            "ext_target_mention_by_map_target_mention",
            "ext_sentences_by_nlp_markup"
          ],
          "input": " SELECT R0.mention_id AS \"target_mention.R0.mention_id\", R0.begin_index AS \"target_mention.R0.begin_index\", R0.end_index AS \"target_mention.R0.end_index\", R0.doc_id AS \"target_mention.R0.doc_id\", R0.sentence_index AS \"target_mention.R0.sentence_index\", R1.tokens AS \"sentences.R1.tokens\", R1.lemmas AS \"sentences.R1.lemmas\", R1.pos_tags AS \"sentences.R1.pos_tags\", R1.ner_tags AS \"sentences.R1.ner_tags\", R1.dep_types AS \"sentences.R1.dep_types\", R1.dep_tokens AS \"sentences.R1.dep_tokens\"\nFROM target_mention R0, sentences R1\n        WHERE R1.doc_id = R0.doc_id  AND R1.sentence_index = R0.sentence_index \n          ",
          "input_batch_size": "100000",
          "input_relations": [
            "target_mention",
            "sentences"
          ],
          "output_relation": "target_feature",
          "parallelism": "1",
          "style": "tsv_extractor",
          "udf": "\"$DEEPDIVE_APP\"/udf/extract_target_features.py"
        },
        "ext_target_label": {
          "cmd": "\n\n\t# TODO use temporary table\n\tdeepdive create table \"target_label\"\n\tdeepdive sql 'INSERT INTO target_label SELECT R0.mention_id AS \"target_mention.R0.mention_id\", R0.mention_text AS \"target_mention.R0.mention_text\", 1 AS column_2, '\\''from_Chemcam_MER'\\'' AS column_3\nFROM target_mention R0, targets_chemcam_mer R1\n        WHERE lower(R1.target_name) = lower(R0.mention_text)\nUNION ALL\nSELECT R0.target_id AS \"target_label__0.R0.target_id\", R0.target_name AS \"target_label__0.R0.target_name\", R0.label AS \"target_label__0.R0.label\", R0.rule_id AS \"target_label__0.R0.rule_id\"\nFROM target_label__0 R0\n        '\n\t# TODO rename temporary table to replace output_relation\n\t\n        ",
          "dependencies": [
            "ext_target_mention_by_map_target_mention",
            "ext_target_label__0_by_supervise"
          ],
          "input_relations": [
            "target_mention",
            "targets_chemcam_mer",
            "target_label__0"
          ],
          "output_relation": "target_label",
          "style": "cmd_extractor"
        },
        "ext_target_label__0_by_supervise": {
          "dependencies": [
            "ext_target_mention_by_map_target_mention",
            "ext_sentences_by_nlp_markup"
          ],
          "input": " SELECT R0.mention_id AS \"target_mention.R0.mention_id\", R0.mention_text AS \"target_mention.R0.mention_text\", R0.begin_index AS \"target_mention.R0.begin_index\", R0.end_index AS \"target_mention.R0.end_index\", R0.doc_id AS \"target_mention.R0.doc_id\", R0.sentence_index AS \"target_mention.R0.sentence_index\", R1.sentence_text AS \"sentences.R1.sentence_text\", R1.tokens AS \"sentences.R1.tokens\", R1.lemmas AS \"sentences.R1.lemmas\", R1.pos_tags AS \"sentences.R1.pos_tags\", R1.ner_tags AS \"sentences.R1.ner_tags\", R1.dep_types AS \"sentences.R1.dep_types\", R1.dep_tokens AS \"sentences.R1.dep_tokens\"\nFROM target_mention R0, sentences R1\n        WHERE R1.doc_id = R0.doc_id  AND R1.sentence_index = R0.sentence_index \n          ",
          "input_batch_size": "100000",
          "input_relations": [
            "target_mention",
            "sentences"
          ],
          "output_relation": "target_label__0",
          "parallelism": "1",
          "style": "tsv_extractor",
          "udf": "\"$DEEPDIVE_APP\"/udf/supervise_targets.py"
        },
        "ext_target_label_resolved": {
          "cmd": "\n\n\tdeepdive create view target_label_resolved as 'SELECT R0.target_id AS column_0, R0.target_name AS column_1, SUM(R0.label) AS column_2\nFROM target_label R0\n        \n        GROUP BY R0.target_id, R0.target_name'\n\t\n        ",
          "dependencies": [
            "ext_target_label"
          ],
          "input_relations": [
            "target_label"
          ],
          "output_relation": "target_label_resolved",
          "style": "cmd_extractor"
        },
        "ext_target_mention_by_map_target_mention": {
          "dependencies": [
            "ext_sentences_by_nlp_markup"
          ],
          "input": " SELECT R0.doc_id AS \"sentences.R0.doc_id\", R0.sentence_index AS \"sentences.R0.sentence_index\", R0.sentence_text AS \"sentences.R0.sentence_text\", R0.tokens AS \"sentences.R0.tokens\"\nFROM sentences R0\n        \n          ",
          "input_batch_size": "100000",
          "input_relations": [
            "sentences"
          ],
          "output_relation": "target_mention",
          "parallelism": "1",
          "style": "tsv_extractor",
          "udf": "\"$DEEPDIVE_APP\"/udf/map_target_mention.py"
        }
      }
    },
    "inference": {
      "factors": {
        "inf_istrue_is_target": {
          "dependencies": [
            "ext_target_mention_by_map_target_mention",
            "ext_target_feature_by_extract_target_features"
          ],
          "function": "Imply(is_target.R0.label)",
          "input_query": "\n          SELECT R0.id AS \"is_target.R0.id\" , R2.feature AS \"dd_weight_column_0\" \n          FROM is_target R0, target_mention R1, target_feature R2\n        WHERE R1.mention_id = R0.target_id  AND R1.mention_text = R0.target_name  AND R2.target_id = R0.target_id ",
          "input_relations": [
            "is_target",
            "target_mention",
            "target_feature"
          ],
          "weight": "?(dd_weight_column_0)"
        }
      }
    },
    "pipeline": {
      "pipelines": {
        "endtoend": [
          "ext_target_mention_by_map_target_mention",
          "ext_person_mention_by_map_person_mention",
          "ext_target_feature_by_extract_target_features",
          "ext_target_label_resolved",
          "ext_target_label",
          "ext_sentences_by_nlp_markup",
          "ext_is_target",
          "ext_target_label__0_by_supervise",
          "inf_istrue_is_target"
        ],
        "extraction": [
          "ext_target_mention_by_map_target_mention",
          "ext_person_mention_by_map_person_mention",
          "ext_target_feature_by_extract_target_features",
          "ext_target_label_resolved",
          "ext_target_label",
          "ext_sentences_by_nlp_markup",
          "ext_is_target",
          "ext_target_label__0_by_supervise"
        ],
        "inference": [
          "inf_istrue_is_target"
        ]
      },
      "run": ""
    },
    "sampler": {
      "sampler_args": "-l 1000 -s 1 -i 1000 --alpha 0.01 --sample_evidence",
      "sampler_cmd": "sampler-dw"
    },
    "schema": {
      "relations": {
        "articles": {
          "annotations": [
            {
              "name": "source"
            }
          ],
          "columns": {
            "content": {
              "annotations": [
                {
                  "name": "searchable"
                }
              ],
              "index": 1,
              "type": "text"
            },
            "id": {
              "annotations": [
                {
                  "name": "key"
                },
                {
                  "name": "distributed_by"
                }
              ],
              "index": 0,
              "type": "text"
            }
          }
        },
        "is_target": {
          "annotations": [
            {
              "name": "extraction"
            }
          ],
          "columns": {
            "target_id": {
              "annotations": [
                {
                  "name": "key"
                },
                {
                  "args": {
                    "alias": "target",
                    "column": "mention_id",
                    "relation": "target_mention"
                  },
                  "name": "references"
                }
              ],
              "index": 0,
              "type": "text"
            },
            "target_name": {
              "annotations": [
                {
                  "name": "key"
                },
                {
                  "args": {
                    "alias": "targetname",
                    "column": "mention_text",
                    "relation": "target_mention"
                  },
                  "name": "references"
                }
              ],
              "index": 1,
              "type": "text"
            }
          },
          "variable_cardinality": 2,
          "variable_type": "boolean"
        },
        "person_mention": {
          "annotations": [
            {
              "name": "extraction"
            }
          ],
          "columns": {
            "doc_id": {
              "annotations": [
                {
                  "name": "distributed_by"
                },
                {
                  "args": {
                    "alias": "appears_in",
                    "column": "doc_id",
                    "relation": "sentences"
                  },
                  "name": "references"
                }
              ],
              "index": 2,
              "type": "text"
            },
            "mention_id": {
              "annotations": [
                {
                  "name": "key"
                }
              ],
              "index": 0,
              "type": "text"
            },
            "mention_text": {
              "annotations": [
                {
                  "name": "searchable"
                }
              ],
              "index": 1,
              "type": "text"
            },
            "sentence_index": {
              "annotations": [
                {
                  "args": {
                    "alias": "appears_in",
                    "column": "sentence_index",
                    "relation": "sentences"
                  },
                  "name": "references"
                }
              ],
              "index": 3,
              "type": "int"
            }
          }
        },
        "sentences": {
          "annotations": [
            {
              "name": "source"
            }
          ],
          "columns": {
            "dep_tokens": {
              "index": 9,
              "type": "int[]"
            },
            "dep_types": {
              "index": 8,
              "type": "text[]"
            },
            "doc_id": {
              "annotations": [
                {
                  "name": "key"
                },
                {
                  "name": "distributed_by"
                }
              ],
              "index": 0,
              "type": "text"
            },
            "doc_offsets": {
              "index": 7,
              "type": "int[]"
            },
            "lemmas": {
              "index": 4,
              "type": "text[]"
            },
            "ner_tags": {
              "index": 6,
              "type": "text[]"
            },
            "pos_tags": {
              "index": 5,
              "type": "text[]"
            },
            "sentence_index": {
              "annotations": [
                {
                  "name": "key"
                }
              ],
              "index": 1,
              "type": "int"
            },
            "sentence_text": {
              "annotations": [
                {
                  "name": "searchable"
                }
              ],
              "index": 2,
              "type": "text"
            },
            "tokens": {
              "index": 3,
              "type": "text[]"
            }
          }
        },
        "target_feature": {
          "annotations": [
            {
              "name": "extraction"
            }
          ],
          "columns": {
            "feature": {
              "annotations": [
                {
                  "name": "key"
                }
              ],
              "index": 1,
              "type": "text"
            },
            "target_id": {
              "annotations": [
                {
                  "name": "key"
                },
                {
                  "args": {
                    "alias": "is_target",
                    "column": "target_id",
                    "relation": "is_target"
                  },
                  "name": "references"
                }
              ],
              "index": 0,
              "type": "text"
            }
          }
        },
        "target_label": {
          "annotations": [
            {
              "name": "extraction"
            }
          ],
          "columns": {
            "label": {
              "annotations": [
                {
                  "name": "navigable"
                }
              ],
              "index": 2,
              "type": "int"
            },
            "rule_id": {
              "annotations": [
                {
                  "name": "navigable"
                }
              ],
              "index": 3,
              "type": "text"
            },
            "target_id": {
              "annotations": [
                {
                  "name": "key"
                },
                {
                  "args": {
                    "alias": "is_target",
                    "column": "target_id",
                    "relation": "is_target"
                  },
                  "name": "references"
                }
              ],
              "index": 0,
              "type": "text"
            },
            "target_name": {
              "annotations": [
                {
                  "name": "searchable"
                }
              ],
              "index": 1,
              "type": "text"
            }
          }
        },
        "target_label__0": {
          "annotations": [
            {
              "name": "extraction"
            }
          ],
          "columns": {
            "label": {
              "annotations": [
                {
                  "name": "navigable"
                }
              ],
              "index": 2,
              "type": "int"
            },
            "rule_id": {
              "annotations": [
                {
                  "name": "navigable"
                }
              ],
              "index": 3,
              "type": "text"
            },
            "target_id": {
              "annotations": [
                {
                  "name": "key"
                },
                {
                  "args": {
                    "alias": "is_target",
                    "column": "target_id",
                    "relation": "is_target"
                  },
                  "name": "references"
                }
              ],
              "index": 0,
              "type": "text"
            },
            "target_name": {
              "annotations": [
                {
                  "name": "searchable"
                }
              ],
              "index": 1,
              "type": "text"
            }
          }
        },
        "target_label_resolved": {
          "columns": {
            "column_0": {
              "index": 0,
              "type": "UNKNOWN"
            },
            "column_1": {
              "index": 1,
              "type": "UNKNOWN"
            },
            "column_2": {
              "index": 2,
              "type": "UNKNOWN"
            }
          },
          "type": "view"
        },
        "target_mention": {
          "annotations": [
            {
              "name": "extraction"
            }
          ],
          "columns": {
            "begin_index": {
              "index": 4,
              "type": "int"
            },
            "doc_id": {
              "annotations": [
                {
                  "name": "distributed_by"
                },
                {
                  "args": {
                    "alias": "appears_in",
                    "column": "doc_id",
                    "relation": "sentences"
                  },
                  "name": "references"
                }
              ],
              "index": 2,
              "type": "text"
            },
            "end_index": {
              "index": 5,
              "type": "int"
            },
            "mention_id": {
              "annotations": [
                {
                  "name": "key"
                }
              ],
              "index": 0,
              "type": "text"
            },
            "mention_text": {
              "annotations": [
                {
                  "name": "searchable"
                }
              ],
              "index": 1,
              "type": "text"
            },
            "sentence_index": {
              "annotations": [
                {
                  "args": {
                    "alias": "appears_in",
                    "column": "sentence_index",
                    "relation": "sentences"
                  },
                  "name": "references"
                }
              ],
              "index": 3,
              "type": "int"
            }
          }
        },
        "targets_chemcam_mer": {
          "annotations": [
            {
              "name": "source"
            }
          ],
          "columns": {
            "target_name": {
              "annotations": [
                {
                  "name": "key"
                }
              ],
              "index": 0,
              "type": "text"
            }
          }
        }
      },
      "variables": {
        "is_target": {
          "label": "Boolean"
        }
      }
    }
  },
  "deepdive_": {
    "calibration": {
      "holdout_fraction": 0.25
    },
    "db": {
      "default": {
        "dbname": "deepdive_planetaryIR_SnehaS",
        "driver": "org.postgresql.Driver",
        "host": "localhost",
        "incremental_mode": "ORIGINAL",
        "password": "",
        "port": "5432",
        "url": "jdbc:postgresql://localhost:5432/deepdive_planetaryIR_SnehaS",
        "user": "SnehaS"
      }
    },
    "extraction": {
      "extractors": {
        "process/ext_is_target": {
          "cmd": "\n\n\t# TODO use temporary table\n\tdeepdive create table \"is_target\"\n\tdeepdive sql 'INSERT INTO is_target SELECT DISTINCT R0.column_0, R0.column_1, 0 AS id, \nCASE WHEN R0.column_2 > 0 THEN true\n     WHEN R0.column_2 < 0 THEN false\n     ELSE NULL\nEND AS label\n          FROM target_label_resolved R0\n        \n          \nUNION ALL\nSELECT DISTINCT R0.mention_id, R0.mention_text, 0 AS id, (NULL :: BOOLEAN) AS label\n          FROM target_mention R0\n        \n          '\n\t# TODO rename temporary table to replace output_relation\n\t\n        ",
          "dependencies": [
            "ext_target_label_resolved",
            "ext_target_mention_by_map_target_mention"
          ],
          "input_relations": [
            "target_label_resolved",
            "target_mention"
          ],
          "output_relation": "is_target",
          "style": "cmd_extractor",
          "dependencies_": [
            "process/ext_target_label_resolved",
            "process/ext_target_mention_by_map_target_mention"
          ],
          "input_": [
            "data/target_label_resolved",
            "data/target_mention"
          ],
          "output_": "data/is_target"
        },
        "process/ext_person_mention_by_map_person_mention": {
          "dependencies": [
            "ext_sentences_by_nlp_markup"
          ],
          "input": " SELECT R0.doc_id AS \"sentences.R0.doc_id\", R0.sentence_index AS \"sentences.R0.sentence_index\", R0.sentence_text AS \"sentences.R0.sentence_text\"\nFROM sentences R0\n        \n          ",
          "input_batch_size": "100000",
          "input_relations": [
            "sentences"
          ],
          "output_relation": "person_mention",
          "parallelism": "1",
          "style": "tsv_extractor",
          "udf": "\"$DEEPDIVE_APP\"/udf/map_person_mention.py",
          "dependencies_": [
            "process/ext_sentences_by_nlp_markup"
          ],
          "input_": [
            "data/sentences"
          ],
          "output_": "data/person_mention"
        },
        "process/ext_sentences_by_nlp_markup": {
          "input": " SELECT R0.id AS \"articles.R0.id\", R0.content AS \"articles.R0.content\"\nFROM articles R0\n        \n          ",
          "input_batch_size": "100000",
          "input_relations": [
            "articles"
          ],
          "output_relation": "sentences",
          "parallelism": "1",
          "style": "tsv_extractor",
          "udf": "\"$DEEPDIVE_APP\"/udf/nlp_markup.sh",
          "dependencies_": [],
          "input_": [
            "data/articles"
          ],
          "output_": "data/sentences"
        },
        "process/ext_target_feature_by_extract_target_features": {
          "dependencies": [
            "ext_target_mention_by_map_target_mention",
            "ext_sentences_by_nlp_markup"
          ],
          "input": " SELECT R0.mention_id AS \"target_mention.R0.mention_id\", R0.begin_index AS \"target_mention.R0.begin_index\", R0.end_index AS \"target_mention.R0.end_index\", R0.doc_id AS \"target_mention.R0.doc_id\", R0.sentence_index AS \"target_mention.R0.sentence_index\", R1.tokens AS \"sentences.R1.tokens\", R1.lemmas AS \"sentences.R1.lemmas\", R1.pos_tags AS \"sentences.R1.pos_tags\", R1.ner_tags AS \"sentences.R1.ner_tags\", R1.dep_types AS \"sentences.R1.dep_types\", R1.dep_tokens AS \"sentences.R1.dep_tokens\"\nFROM target_mention R0, sentences R1\n        WHERE R1.doc_id = R0.doc_id  AND R1.sentence_index = R0.sentence_index \n          ",
          "input_batch_size": "100000",
          "input_relations": [
            "target_mention",
            "sentences"
          ],
          "output_relation": "target_feature",
          "parallelism": "1",
          "style": "tsv_extractor",
          "udf": "\"$DEEPDIVE_APP\"/udf/extract_target_features.py",
          "dependencies_": [
            "process/ext_target_mention_by_map_target_mention",
            "process/ext_sentences_by_nlp_markup"
          ],
          "input_": [
            "data/target_mention",
            "data/sentences"
          ],
          "output_": "data/target_feature"
        },
        "process/ext_target_label": {
          "cmd": "\n\n\t# TODO use temporary table\n\tdeepdive create table \"target_label\"\n\tdeepdive sql 'INSERT INTO target_label SELECT R0.mention_id AS \"target_mention.R0.mention_id\", R0.mention_text AS \"target_mention.R0.mention_text\", 1 AS column_2, '\\''from_Chemcam_MER'\\'' AS column_3\nFROM target_mention R0, targets_chemcam_mer R1\n        WHERE lower(R1.target_name) = lower(R0.mention_text)\nUNION ALL\nSELECT R0.target_id AS \"target_label__0.R0.target_id\", R0.target_name AS \"target_label__0.R0.target_name\", R0.label AS \"target_label__0.R0.label\", R0.rule_id AS \"target_label__0.R0.rule_id\"\nFROM target_label__0 R0\n        '\n\t# TODO rename temporary table to replace output_relation\n\t\n        ",
          "dependencies": [
            "ext_target_mention_by_map_target_mention",
            "ext_target_label__0_by_supervise"
          ],
          "input_relations": [
            "target_mention",
            "targets_chemcam_mer",
            "target_label__0"
          ],
          "output_relation": "target_label",
          "style": "cmd_extractor",
          "dependencies_": [
            "process/ext_target_mention_by_map_target_mention",
            "process/ext_target_label__0_by_supervise"
          ],
          "input_": [
            "data/target_mention",
            "data/targets_chemcam_mer",
            "data/target_label__0"
          ],
          "output_": "data/target_label"
        },
        "process/ext_target_label__0_by_supervise": {
          "dependencies": [
            "ext_target_mention_by_map_target_mention",
            "ext_sentences_by_nlp_markup"
          ],
          "input": " SELECT R0.mention_id AS \"target_mention.R0.mention_id\", R0.mention_text AS \"target_mention.R0.mention_text\", R0.begin_index AS \"target_mention.R0.begin_index\", R0.end_index AS \"target_mention.R0.end_index\", R0.doc_id AS \"target_mention.R0.doc_id\", R0.sentence_index AS \"target_mention.R0.sentence_index\", R1.sentence_text AS \"sentences.R1.sentence_text\", R1.tokens AS \"sentences.R1.tokens\", R1.lemmas AS \"sentences.R1.lemmas\", R1.pos_tags AS \"sentences.R1.pos_tags\", R1.ner_tags AS \"sentences.R1.ner_tags\", R1.dep_types AS \"sentences.R1.dep_types\", R1.dep_tokens AS \"sentences.R1.dep_tokens\"\nFROM target_mention R0, sentences R1\n        WHERE R1.doc_id = R0.doc_id  AND R1.sentence_index = R0.sentence_index \n          ",
          "input_batch_size": "100000",
          "input_relations": [
            "target_mention",
            "sentences"
          ],
          "output_relation": "target_label__0",
          "parallelism": "1",
          "style": "tsv_extractor",
          "udf": "\"$DEEPDIVE_APP\"/udf/supervise_targets.py",
          "dependencies_": [
            "process/ext_target_mention_by_map_target_mention",
            "process/ext_sentences_by_nlp_markup"
          ],
          "input_": [
            "data/target_mention",
            "data/sentences"
          ],
          "output_": "data/target_label__0"
        },
        "process/ext_target_label_resolved": {
          "cmd": "\n\n\tdeepdive create view target_label_resolved as 'SELECT R0.target_id AS column_0, R0.target_name AS column_1, SUM(R0.label) AS column_2\nFROM target_label R0\n        \n        GROUP BY R0.target_id, R0.target_name'\n\t\n        ",
          "dependencies": [
            "ext_target_label"
          ],
          "input_relations": [
            "target_label"
          ],
          "output_relation": "target_label_resolved",
          "style": "cmd_extractor",
          "dependencies_": [
            "process/ext_target_label"
          ],
          "input_": [
            "data/target_label"
          ],
          "output_": "data/target_label_resolved"
        },
        "process/ext_target_mention_by_map_target_mention": {
          "dependencies": [
            "ext_sentences_by_nlp_markup"
          ],
          "input": " SELECT R0.doc_id AS \"sentences.R0.doc_id\", R0.sentence_index AS \"sentences.R0.sentence_index\", R0.sentence_text AS \"sentences.R0.sentence_text\", R0.tokens AS \"sentences.R0.tokens\"\nFROM sentences R0\n        \n          ",
          "input_batch_size": "100000",
          "input_relations": [
            "sentences"
          ],
          "output_relation": "target_mention",
          "parallelism": "1",
          "style": "tsv_extractor",
          "udf": "\"$DEEPDIVE_APP\"/udf/map_target_mention.py",
          "dependencies_": [
            "process/ext_sentences_by_nlp_markup"
          ],
          "input_": [
            "data/sentences"
          ],
          "output_": "data/target_mention"
        }
      }
    },
    "inference": {
      "factors": {
        "factor/inf_istrue_is_target": {
          "dependencies": [
            "ext_target_mention_by_map_target_mention",
            "ext_target_feature_by_extract_target_features"
          ],
          "function": "Imply(is_target.R0.label)",
          "input_query": "\n          SELECT R0.id AS \"is_target.R0.id\" , R2.feature AS \"dd_weight_column_0\" \n          FROM is_target R0, target_mention R1, target_feature R2\n        WHERE R1.mention_id = R0.target_id  AND R1.mention_text = R0.target_name  AND R2.target_id = R0.target_id ",
          "input_relations": [
            "is_target",
            "target_mention",
            "target_feature"
          ],
          "weight": "?(dd_weight_column_0)",
          "dependencies_": [
            "process/ext_target_mention_by_map_target_mention",
            "process/ext_target_feature_by_extract_target_features"
          ],
          "input_": [
            "data/is_target",
            "data/target_mention",
            "data/target_feature"
          ],
          "output_": null
        }
      },
      "factors_": [
        {
          "dependencies": [
            "ext_target_mention_by_map_target_mention",
            "ext_target_feature_by_extract_target_features"
          ],
          "function": "Imply(is_target.R0.label)",
          "input_query": "\n          SELECT R0.id AS \"is_target.R0.id\" , R2.feature AS \"dd_weight_column_0\" \n          FROM is_target R0, target_mention R1, target_feature R2\n        WHERE R1.mention_id = R0.target_id  AND R1.mention_text = R0.target_name  AND R2.target_id = R0.target_id ",
          "input_relations": [
            "is_target",
            "target_mention",
            "target_feature"
          ],
          "weight": "?(dd_weight_column_0)",
          "dependencies_": [
            "process/ext_target_mention_by_map_target_mention",
            "process/ext_target_feature_by_extract_target_features"
          ],
          "input_": [
            "data/is_target",
            "data/target_mention",
            "data/target_feature"
          ],
          "output_": null,
          "factorName": "inf_istrue_is_target",
          "factorsTable": "dd_factors_inf_istrue_is_target",
          "weightsTable": "dd_weights_inf_istrue_is_target",
          "weight_": {
            "is_fixed": false,
            "params": [
              "dd_weight_column_0"
            ],
            "init_value": 0
          },
          "function_": {
            "name": "imply",
            "variables": [
              {
                "isNegated": false,
                "columnLabel": "is_target.R0.label",
                "columnPrefix": "is_target.R0.",
                "name": "is_target",
                "columnLabelName": "label",
                "isArray": false,
                "equalsTo": null,
                "columnId": "is_target.R0.id",
                "schema": {
                  "variableName": "is_target",
                  "variablesTable": "is_target",
                  "variablesLabelColumn": "label",
                  "variableCategoriesTable": "dd_categories_is_target",
                  "isBooleanType": true,
                  "isCategoricalType": false,
                  "variableCardinality": 2,
                  "variableType": "boolean"
                },
                "ordinal": 0
              }
            ],
            "id": 0
          },
          "weightsTableForDumping": "dd_weights_inf_istrue_is_target"
        }
      ],
      "factors_byName": {
        "inf_istrue_is_target": {
          "dependencies": [
            "ext_target_mention_by_map_target_mention",
            "ext_target_feature_by_extract_target_features"
          ],
          "function": "Imply(is_target.R0.label)",
          "input_query": "\n          SELECT R0.id AS \"is_target.R0.id\" , R2.feature AS \"dd_weight_column_0\" \n          FROM is_target R0, target_mention R1, target_feature R2\n        WHERE R1.mention_id = R0.target_id  AND R1.mention_text = R0.target_name  AND R2.target_id = R0.target_id ",
          "input_relations": [
            "is_target",
            "target_mention",
            "target_feature"
          ],
          "weight": "?(dd_weight_column_0)",
          "dependencies_": [
            "process/ext_target_mention_by_map_target_mention",
            "process/ext_target_feature_by_extract_target_features"
          ],
          "input_": [
            "data/is_target",
            "data/target_mention",
            "data/target_feature"
          ],
          "output_": null,
          "factorName": "inf_istrue_is_target",
          "factorsTable": "dd_factors_inf_istrue_is_target",
          "weightsTable": "dd_weights_inf_istrue_is_target",
          "weight_": {
            "is_fixed": false,
            "params": [
              "dd_weight_column_0"
            ],
            "init_value": 0
          },
          "function_": {
            "name": "imply",
            "variables": [
              {
                "isNegated": false,
                "columnLabel": "is_target.R0.label",
                "columnPrefix": "is_target.R0.",
                "name": "is_target",
                "columnLabelName": "label",
                "isArray": false,
                "equalsTo": null,
                "columnId": "is_target.R0.id",
                "schema": {
                  "variableName": "is_target",
                  "variablesTable": "is_target",
                  "variablesLabelColumn": "label",
                  "variableCategoriesTable": "dd_categories_is_target",
                  "isBooleanType": true,
                  "isCategoricalType": false,
                  "variableCardinality": 2,
                  "variableType": "boolean"
                },
                "ordinal": 0
              }
            ],
            "id": 0
          },
          "weightsTableForDumping": "dd_weights_inf_istrue_is_target"
        }
      }
    },
    "pipeline": {
      "pipelines": {
        "pipeline/endtoend": [
          "process/ext_target_mention_by_map_target_mention",
          "process/ext_person_mention_by_map_person_mention",
          "process/ext_target_feature_by_extract_target_features",
          "process/ext_target_label_resolved",
          "process/ext_target_label",
          "process/ext_sentences_by_nlp_markup",
          "process/ext_is_target",
          "process/ext_target_label__0_by_supervise",
          "factor/inf_istrue_is_target"
        ],
        "pipeline/extraction": [
          "process/ext_target_mention_by_map_target_mention",
          "process/ext_person_mention_by_map_person_mention",
          "process/ext_target_feature_by_extract_target_features",
          "process/ext_target_label_resolved",
          "process/ext_target_label",
          "process/ext_sentences_by_nlp_markup",
          "process/ext_is_target",
          "process/ext_target_label__0_by_supervise"
        ],
        "pipeline/inference": [
          "factor/inf_istrue_is_target"
        ]
      },
      "run": ""
    },
    "sampler": {
      "sampler_args": "-l 1000 -s 1 -i 1000 --alpha 0.01 --sample_evidence",
      "sampler_cmd": "sampler-dw"
    },
    "schema": {
      "relations": {
        "articles": {
          "annotations": [
            {
              "name": "source"
            }
          ],
          "columns": {
            "content": {
              "annotations": [
                {
                  "name": "searchable"
                }
              ],
              "index": 1,
              "type": "text"
            },
            "id": {
              "annotations": [
                {
                  "name": "key"
                },
                {
                  "name": "distributed_by"
                }
              ],
              "index": 0,
              "type": "text"
            }
          }
        },
        "is_target": {
          "annotations": [
            {
              "name": "extraction"
            }
          ],
          "columns": {
            "target_id": {
              "annotations": [
                {
                  "name": "key"
                },
                {
                  "args": {
                    "alias": "target",
                    "column": "mention_id",
                    "relation": "target_mention"
                  },
                  "name": "references"
                }
              ],
              "index": 0,
              "type": "text"
            },
            "target_name": {
              "annotations": [
                {
                  "name": "key"
                },
                {
                  "args": {
                    "alias": "targetname",
                    "column": "mention_text",
                    "relation": "target_mention"
                  },
                  "name": "references"
                }
              ],
              "index": 1,
              "type": "text"
            }
          },
          "variable_cardinality": 2,
          "variable_type": "boolean"
        },
        "person_mention": {
          "annotations": [
            {
              "name": "extraction"
            }
          ],
          "columns": {
            "doc_id": {
              "annotations": [
                {
                  "name": "distributed_by"
                },
                {
                  "args": {
                    "alias": "appears_in",
                    "column": "doc_id",
                    "relation": "sentences"
                  },
                  "name": "references"
                }
              ],
              "index": 2,
              "type": "text"
            },
            "mention_id": {
              "annotations": [
                {
                  "name": "key"
                }
              ],
              "index": 0,
              "type": "text"
            },
            "mention_text": {
              "annotations": [
                {
                  "name": "searchable"
                }
              ],
              "index": 1,
              "type": "text"
            },
            "sentence_index": {
              "annotations": [
                {
                  "args": {
                    "alias": "appears_in",
                    "column": "sentence_index",
                    "relation": "sentences"
                  },
                  "name": "references"
                }
              ],
              "index": 3,
              "type": "int"
            }
          }
        },
        "sentences": {
          "annotations": [
            {
              "name": "source"
            }
          ],
          "columns": {
            "dep_tokens": {
              "index": 9,
              "type": "int[]"
            },
            "dep_types": {
              "index": 8,
              "type": "text[]"
            },
            "doc_id": {
              "annotations": [
                {
                  "name": "key"
                },
                {
                  "name": "distributed_by"
                }
              ],
              "index": 0,
              "type": "text"
            },
            "doc_offsets": {
              "index": 7,
              "type": "int[]"
            },
            "lemmas": {
              "index": 4,
              "type": "text[]"
            },
            "ner_tags": {
              "index": 6,
              "type": "text[]"
            },
            "pos_tags": {
              "index": 5,
              "type": "text[]"
            },
            "sentence_index": {
              "annotations": [
                {
                  "name": "key"
                }
              ],
              "index": 1,
              "type": "int"
            },
            "sentence_text": {
              "annotations": [
                {
                  "name": "searchable"
                }
              ],
              "index": 2,
              "type": "text"
            },
            "tokens": {
              "index": 3,
              "type": "text[]"
            }
          }
        },
        "target_feature": {
          "annotations": [
            {
              "name": "extraction"
            }
          ],
          "columns": {
            "feature": {
              "annotations": [
                {
                  "name": "key"
                }
              ],
              "index": 1,
              "type": "text"
            },
            "target_id": {
              "annotations": [
                {
                  "name": "key"
                },
                {
                  "args": {
                    "alias": "is_target",
                    "column": "target_id",
                    "relation": "is_target"
                  },
                  "name": "references"
                }
              ],
              "index": 0,
              "type": "text"
            }
          }
        },
        "target_label": {
          "annotations": [
            {
              "name": "extraction"
            }
          ],
          "columns": {
            "label": {
              "annotations": [
                {
                  "name": "navigable"
                }
              ],
              "index": 2,
              "type": "int"
            },
            "rule_id": {
              "annotations": [
                {
                  "name": "navigable"
                }
              ],
              "index": 3,
              "type": "text"
            },
            "target_id": {
              "annotations": [
                {
                  "name": "key"
                },
                {
                  "args": {
                    "alias": "is_target",
                    "column": "target_id",
                    "relation": "is_target"
                  },
                  "name": "references"
                }
              ],
              "index": 0,
              "type": "text"
            },
            "target_name": {
              "annotations": [
                {
                  "name": "searchable"
                }
              ],
              "index": 1,
              "type": "text"
            }
          }
        },
        "target_label__0": {
          "annotations": [
            {
              "name": "extraction"
            }
          ],
          "columns": {
            "label": {
              "annotations": [
                {
                  "name": "navigable"
                }
              ],
              "index": 2,
              "type": "int"
            },
            "rule_id": {
              "annotations": [
                {
                  "name": "navigable"
                }
              ],
              "index": 3,
              "type": "text"
            },
            "target_id": {
              "annotations": [
                {
                  "name": "key"
                },
                {
                  "args": {
                    "alias": "is_target",
                    "column": "target_id",
                    "relation": "is_target"
                  },
                  "name": "references"
                }
              ],
              "index": 0,
              "type": "text"
            },
            "target_name": {
              "annotations": [
                {
                  "name": "searchable"
                }
              ],
              "index": 1,
              "type": "text"
            }
          }
        },
        "target_label_resolved": {
          "columns": {
            "column_0": {
              "index": 0,
              "type": "UNKNOWN"
            },
            "column_1": {
              "index": 1,
              "type": "UNKNOWN"
            },
            "column_2": {
              "index": 2,
              "type": "UNKNOWN"
            }
          },
          "type": "view"
        },
        "target_mention": {
          "annotations": [
            {
              "name": "extraction"
            }
          ],
          "columns": {
            "begin_index": {
              "index": 4,
              "type": "int"
            },
            "doc_id": {
              "annotations": [
                {
                  "name": "distributed_by"
                },
                {
                  "args": {
                    "alias": "appears_in",
                    "column": "doc_id",
                    "relation": "sentences"
                  },
                  "name": "references"
                }
              ],
              "index": 2,
              "type": "text"
            },
            "end_index": {
              "index": 5,
              "type": "int"
            },
            "mention_id": {
              "annotations": [
                {
                  "name": "key"
                }
              ],
              "index": 0,
              "type": "text"
            },
            "mention_text": {
              "annotations": [
                {
                  "name": "searchable"
                }
              ],
              "index": 1,
              "type": "text"
            },
            "sentence_index": {
              "annotations": [
                {
                  "args": {
                    "alias": "appears_in",
                    "column": "sentence_index",
                    "relation": "sentences"
                  },
                  "name": "references"
                }
              ],
              "index": 3,
              "type": "int"
            }
          }
        },
        "targets_chemcam_mer": {
          "annotations": [
            {
              "name": "source"
            }
          ],
          "columns": {
            "target_name": {
              "annotations": [
                {
                  "name": "key"
                }
              ],
              "index": 0,
              "type": "text"
            }
          }
        }
      },
      "variables": {
        "is_target": {
          "label": "Boolean"
        }
      },
      "variables_": [
        {
          "variableName": "is_target",
          "variablesTable": "is_target",
          "variablesLabelColumn": "label",
          "variableCategoriesTable": "dd_categories_is_target",
          "isBooleanType": true,
          "isCategoricalType": false,
          "variableCardinality": 2,
          "variableType": "boolean"
        }
      ],
      "variables_byName": {
        "is_target": {
          "variableName": "is_target",
          "variablesTable": "is_target",
          "variablesLabelColumn": "label",
          "variableCategoriesTable": "dd_categories_is_target",
          "isBooleanType": true,
          "isCategoricalType": false,
          "variableCardinality": 2,
          "variableType": "boolean"
        }
      }
    },
    "execution": {
      "processes": {
        "process/init/app": {
          "style": "cmd_extractor",
          "cmd": "\n        deepdive db init\n\n        cd \"$DEEPDIVE_APP\"\n        # run legacy schema.sql\n        if [[ -r schema.sql ]]; then\n            deepdive db prompt <schema.sql\n        fi\n        # run legacy init script\n        if [[ -x input/init.sh ]]; then\n            input/init.sh\n        fi\n        "
        },
        "process/init/relation/articles": {
          "style": "cmd_extractor",
          "cmd": "deepdive create table 'articles' && deepdive load 'articles'",
          "dependencies_": [
            "process/init/app"
          ],
          "output_relation": "articles",
          "output_": "data/articles"
        },
        "process/init/relation/targets_chemcam_mer": {
          "style": "cmd_extractor",
          "cmd": "deepdive create table 'targets_chemcam_mer' && deepdive load 'targets_chemcam_mer'",
          "dependencies_": [
            "process/init/app"
          ],
          "output_relation": "targets_chemcam_mer",
          "output_": "data/targets_chemcam_mer"
        },
        "process/ext_is_target": {
          "cmd": "\n\n\t# TODO use temporary table\n\tdeepdive create table \"is_target\"\n\tdeepdive sql 'INSERT INTO is_target SELECT DISTINCT R0.column_0, R0.column_1, 0 AS id, \nCASE WHEN R0.column_2 > 0 THEN true\n     WHEN R0.column_2 < 0 THEN false\n     ELSE NULL\nEND AS label\n          FROM target_label_resolved R0\n        \n          \nUNION ALL\nSELECT DISTINCT R0.mention_id, R0.mention_text, 0 AS id, (NULL :: BOOLEAN) AS label\n          FROM target_mention R0\n        \n          '\n\t# TODO rename temporary table to replace output_relation\n\t\n        ",
          "dependencies": [
            "ext_target_label_resolved",
            "ext_target_mention_by_map_target_mention"
          ],
          "input_relations": [
            "target_label_resolved",
            "target_mention"
          ],
          "output_relation": "is_target",
          "style": "cmd_extractor",
          "dependencies_": [
            "process/ext_target_label_resolved",
            "process/ext_target_mention_by_map_target_mention"
          ],
          "input_": [
            "data/target_label_resolved",
            "data/target_mention"
          ],
          "output_": "data/is_target"
        },
        "process/ext_person_mention_by_map_person_mention": {
          "dependencies": [
            "ext_sentences_by_nlp_markup"
          ],
          "input": " SELECT R0.doc_id AS \"sentences.R0.doc_id\", R0.sentence_index AS \"sentences.R0.sentence_index\", R0.sentence_text AS \"sentences.R0.sentence_text\"\nFROM sentences R0\n        \n          ",
          "input_batch_size": "100000",
          "input_relations": [
            "sentences"
          ],
          "output_relation": "person_mention",
          "parallelism": "1",
          "style": "tsv_extractor",
          "udf": "\"$DEEPDIVE_APP\"/udf/map_person_mention.py",
          "dependencies_": [
            "process/ext_sentences_by_nlp_markup"
          ],
          "input_": [
            "data/sentences"
          ],
          "output_": "data/person_mention"
        },
        "process/ext_sentences_by_nlp_markup": {
          "input": " SELECT R0.id AS \"articles.R0.id\", R0.content AS \"articles.R0.content\"\nFROM articles R0\n        \n          ",
          "input_batch_size": "100000",
          "input_relations": [
            "articles"
          ],
          "output_relation": "sentences",
          "parallelism": "1",
          "style": "tsv_extractor",
          "udf": "\"$DEEPDIVE_APP\"/udf/nlp_markup.sh",
          "dependencies_": [],
          "input_": [
            "data/articles"
          ],
          "output_": "data/sentences"
        },
        "process/ext_target_feature_by_extract_target_features": {
          "dependencies": [
            "ext_target_mention_by_map_target_mention",
            "ext_sentences_by_nlp_markup"
          ],
          "input": " SELECT R0.mention_id AS \"target_mention.R0.mention_id\", R0.begin_index AS \"target_mention.R0.begin_index\", R0.end_index AS \"target_mention.R0.end_index\", R0.doc_id AS \"target_mention.R0.doc_id\", R0.sentence_index AS \"target_mention.R0.sentence_index\", R1.tokens AS \"sentences.R1.tokens\", R1.lemmas AS \"sentences.R1.lemmas\", R1.pos_tags AS \"sentences.R1.pos_tags\", R1.ner_tags AS \"sentences.R1.ner_tags\", R1.dep_types AS \"sentences.R1.dep_types\", R1.dep_tokens AS \"sentences.R1.dep_tokens\"\nFROM target_mention R0, sentences R1\n        WHERE R1.doc_id = R0.doc_id  AND R1.sentence_index = R0.sentence_index \n          ",
          "input_batch_size": "100000",
          "input_relations": [
            "target_mention",
            "sentences"
          ],
          "output_relation": "target_feature",
          "parallelism": "1",
          "style": "tsv_extractor",
          "udf": "\"$DEEPDIVE_APP\"/udf/extract_target_features.py",
          "dependencies_": [
            "process/ext_target_mention_by_map_target_mention",
            "process/ext_sentences_by_nlp_markup"
          ],
          "input_": [
            "data/target_mention",
            "data/sentences"
          ],
          "output_": "data/target_feature"
        },
        "process/ext_target_label": {
          "cmd": "\n\n\t# TODO use temporary table\n\tdeepdive create table \"target_label\"\n\tdeepdive sql 'INSERT INTO target_label SELECT R0.mention_id AS \"target_mention.R0.mention_id\", R0.mention_text AS \"target_mention.R0.mention_text\", 1 AS column_2, '\\''from_Chemcam_MER'\\'' AS column_3\nFROM target_mention R0, targets_chemcam_mer R1\n        WHERE lower(R1.target_name) = lower(R0.mention_text)\nUNION ALL\nSELECT R0.target_id AS \"target_label__0.R0.target_id\", R0.target_name AS \"target_label__0.R0.target_name\", R0.label AS \"target_label__0.R0.label\", R0.rule_id AS \"target_label__0.R0.rule_id\"\nFROM target_label__0 R0\n        '\n\t# TODO rename temporary table to replace output_relation\n\t\n        ",
          "dependencies": [
            "ext_target_mention_by_map_target_mention",
            "ext_target_label__0_by_supervise"
          ],
          "input_relations": [
            "target_mention",
            "targets_chemcam_mer",
            "target_label__0"
          ],
          "output_relation": "target_label",
          "style": "cmd_extractor",
          "dependencies_": [
            "process/ext_target_mention_by_map_target_mention",
            "process/ext_target_label__0_by_supervise"
          ],
          "input_": [
            "data/target_mention",
            "data/targets_chemcam_mer",
            "data/target_label__0"
          ],
          "output_": "data/target_label"
        },
        "process/ext_target_label__0_by_supervise": {
          "dependencies": [
            "ext_target_mention_by_map_target_mention",
            "ext_sentences_by_nlp_markup"
          ],
          "input": " SELECT R0.mention_id AS \"target_mention.R0.mention_id\", R0.mention_text AS \"target_mention.R0.mention_text\", R0.begin_index AS \"target_mention.R0.begin_index\", R0.end_index AS \"target_mention.R0.end_index\", R0.doc_id AS \"target_mention.R0.doc_id\", R0.sentence_index AS \"target_mention.R0.sentence_index\", R1.sentence_text AS \"sentences.R1.sentence_text\", R1.tokens AS \"sentences.R1.tokens\", R1.lemmas AS \"sentences.R1.lemmas\", R1.pos_tags AS \"sentences.R1.pos_tags\", R1.ner_tags AS \"sentences.R1.ner_tags\", R1.dep_types AS \"sentences.R1.dep_types\", R1.dep_tokens AS \"sentences.R1.dep_tokens\"\nFROM target_mention R0, sentences R1\n        WHERE R1.doc_id = R0.doc_id  AND R1.sentence_index = R0.sentence_index \n          ",
          "input_batch_size": "100000",
          "input_relations": [
            "target_mention",
            "sentences"
          ],
          "output_relation": "target_label__0",
          "parallelism": "1",
          "style": "tsv_extractor",
          "udf": "\"$DEEPDIVE_APP\"/udf/supervise_targets.py",
          "dependencies_": [
            "process/ext_target_mention_by_map_target_mention",
            "process/ext_sentences_by_nlp_markup"
          ],
          "input_": [
            "data/target_mention",
            "data/sentences"
          ],
          "output_": "data/target_label__0"
        },
        "process/ext_target_label_resolved": {
          "cmd": "\n\n\tdeepdive create view target_label_resolved as 'SELECT R0.target_id AS column_0, R0.target_name AS column_1, SUM(R0.label) AS column_2\nFROM target_label R0\n        \n        GROUP BY R0.target_id, R0.target_name'\n\t\n        ",
          "dependencies": [
            "ext_target_label"
          ],
          "input_relations": [
            "target_label"
          ],
          "output_relation": "target_label_resolved",
          "style": "cmd_extractor",
          "dependencies_": [
            "process/ext_target_label"
          ],
          "input_": [
            "data/target_label"
          ],
          "output_": "data/target_label_resolved"
        },
        "process/ext_target_mention_by_map_target_mention": {
          "dependencies": [
            "ext_sentences_by_nlp_markup"
          ],
          "input": " SELECT R0.doc_id AS \"sentences.R0.doc_id\", R0.sentence_index AS \"sentences.R0.sentence_index\", R0.sentence_text AS \"sentences.R0.sentence_text\", R0.tokens AS \"sentences.R0.tokens\"\nFROM sentences R0\n        \n          ",
          "input_batch_size": "100000",
          "input_relations": [
            "sentences"
          ],
          "output_relation": "target_mention",
          "parallelism": "1",
          "style": "tsv_extractor",
          "udf": "\"$DEEPDIVE_APP\"/udf/map_target_mention.py",
          "dependencies_": [
            "process/ext_sentences_by_nlp_markup"
          ],
          "input_": [
            "data/sentences"
          ],
          "output_": "data/target_mention"
        },
        "process/grounding/variable_id_partition": {
          "dependencies_": [
            "data/is_target"
          ],
          "style": "cmd_extractor",
          "cmd": "\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n        RANGE_BEGIN=0 \\\n        partition_id_range 'is_target' | {\n            # record the base\n            variableCountTotal=0\n            while read table begin excludeEnd; do\n                varPath=\"$DEEPDIVE_GROUNDING_DIR\"/variable/${table}\n                mkdir -p \"$varPath\"\n                cd \"$varPath\"\n                echo $begin                      >id_begin\n                echo $excludeEnd                 >id_exclude_end\n                echo $(( $excludeEnd - $begin )) >count\n                variableCountTotal=$excludeEnd\n            done\n            # record the final count\n            echo $variableCountTotal >\"$DEEPDIVE_GROUNDING_DIR\"/variable_count\n        }\n        "
        },
        "process/grounding/variable/is_target/assign_id": {
          "dependencies_": [
            "process/grounding/variable_id_partition"
          ],
          "style": "cmd_extractor",
          "cmd": "\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n        table='is_target'\n\n        cd \"$DEEPDIVE_GROUNDING_DIR\"/variable/${table}\n        baseId=$(cat id_begin)\n\n        # assign id to all rows according to the paritition\n        deepdive db assign_sequential_id $table 'id' $baseId\n\n        \n        "
        },
        "process/grounding/variable_holdout": {
          "dependencies_": [
            "process/grounding/variable/is_target/assign_id"
          ],
          "style": "cmd_extractor",
          "cmd": "\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n        deepdive create table 'dd_graph_variables_holdout' \\\n            variable_id:BIGINT:'PRIMARY KEY' \\\n            #\n        deepdive create table 'dd_graph_variables_observation' \\\n            variable_id:BIGINT:'PRIMARY KEY' \\\n            #\n        deepdive sql '\n                INSERT INTO \"dd_graph_variables_holdout\" SELECT \"id\"\nFROM \"is_target\"\n\nWHERE \"label\" IS NOT NULL AND RANDOM() < 0.25;\n            '\n        "
        },
        "process/grounding/variable/is_target/dump": {
          "dependencies_": [
            "process/grounding/variable_holdout"
          ],
          "style": "cmd_extractor",
          "cmd": "\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n        table='is_target'\n\n        varPath=\"$DEEPDIVE_GROUNDING_DIR\"/variable/'is_target'\n        mkdir -p \"$varPath\"\n        cd \"$varPath\"\n        find . -name 'variables.part-*.bin.bz2' -exec rm -rf {} +\n        export DEEPDIVE_LOAD_FORMAT=tsv\n        export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n        # dump the variables, joining the holdout query to determine the type of each variable\n        deepdive compute execute \\\n            input_sql='SELECT \"id\"\n     , \"variable_role\"\n     , CASE WHEN variable_role = 0 THEN 0\n                          ELSE (CASE WHEN label THEN 1 ELSE 0 END) + 0.0\n                      END AS \"init_value\"\n     , \"variable_type\"\n     , \"cardinality\"\nFROM (SELECT \"id\" AS \"id\"\n     , CASE WHEN               observation.variable_id IS NOT NULL\n                                     AND variables.\"label\" IS NOT NULL THEN 2\n                                    WHEN               holdout.variable_id IS NOT NULL THEN 0\n                                    WHEN variables.\"label\" IS NOT NULL THEN 1\n                                                                                       ELSE 0\n                                END AS \"variable_role\"\n     , \"variables\".\"label\" AS \"label\"\n     , 0 AS \"variable_type\"\n     , 2 AS \"cardinality\"\nFROM \"is_target\" \"variables\"\nLEFT OUTER JOIN \"dd_graph_variables_holdout\" \"holdout\" ON \"variables\".\"id\" = \"holdout\".\"variable_id\" LEFT OUTER JOIN \"dd_graph_variables_observation\" \"observation\" ON \"variables\".\"id\" = \"observation\".\"variable_id\") \"variables\"' \\\n            command='\n                format_converter variable /dev/stdin >(pbzip2 >variables.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\n            ' \\\n            output_relation=\n        "
        },
        "process/grounding/factor/inf_istrue_is_target/materialize": {
          "dependencies_": [
            "process/grounding/variable/is_target/assign_id"
          ],
          "input_": [
            "data/target_mention",
            "data/target_feature"
          ],
          "style": "cmd_extractor",
          "cmd": "\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n            # materialize factors using user input_query that pulls in assigned ids to involved variables\n            deepdive create table 'dd_factors_inf_istrue_is_target' as '\n          SELECT R0.id AS \"is_target.R0.id\" , R2.feature AS \"dd_weight_column_0\" \n          FROM is_target R0, target_mention R1, target_feature R2\n        WHERE R1.mention_id = R0.target_id  AND R1.mention_text = R0.target_name  AND R2.target_id = R0.target_id '\n\n            # find distinct weights for the factors into a separate table\n            deepdive create table 'dd_weights_inf_istrue_is_target' as 'SELECT \"dd_weight_column_0\"\n     , false AS \"isfixed\"\n     , 0 AS \"initvalue\"\n     , -1 AS \"id\"\nFROM \"dd_factors_inf_istrue_is_target\"\n\n\nGROUP BY \"dd_weight_column_0\"'\n        "
        },
        "process/grounding/weight_id_partition": {
          "dependencies_": [
            "process/grounding/factor/inf_istrue_is_target/materialize"
          ],
          "style": "cmd_extractor",
          "cmd": "\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n        # partition the id range for weights\n        RANGE_BEGIN=0 RANGE_STEP=1 \\\n        partition_id_range 'dd_weights_inf_istrue_is_target' | {\n            weightsCountTotal=0\n            while read table begin excludeEnd; do\n                factor=${table#'dd_weights_'}\n                facPath=\"$DEEPDIVE_GROUNDING_DIR\"/factor/${factor}\n                mkdir -p \"$facPath\"\n                cd \"$facPath\"\n                echo $begin                      >weights_id_begin\n                echo $excludeEnd                 >weights_id_exclude_end\n                echo $(( $excludeEnd - $begin )) >weights_count\n                weightsCountTotal=$excludeEnd\n            done\n            echo $weightsCountTotal >\"$DEEPDIVE_GROUNDING_DIR\"/factor/weights_count\n        }\n        "
        },
        "process/grounding/global_weight_table": {
          "dependencies_": [
            "process/grounding/factor/inf_istrue_is_target/materialize"
          ],
          "style": "cmd_extractor",
          "cmd": "\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n        # set up a union view for all weight tables (\"dd_graph_weights\")\n        deepdive create view 'dd_graph_weights' as '(SELECT \"id\"\n     , \"isfixed\"\n     , \"initvalue\"\n     , '\\''inf_istrue_is_target-'\\'' ||'\\''-'\\''|| CASE WHEN \"dd_weight_column_0\" IS NULL THEN '\\'''\\''\n              ELSE \"dd_weight_column_0\" || '\\'''\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\n          END AS \"description\"\n     , NULL AS \"categories\"\nFROM \"dd_weights_inf_istrue_is_target\")'\n        "
        },
        "process/grounding/factor/inf_istrue_is_target/assign_weight_id": {
          "dependencies_": [
            "process/grounding/weight_id_partition"
          ],
          "style": "cmd_extractor",
          "cmd": "\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n\n            cd \"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_is_target'\n            baseId=$(cat weights_id_begin)\n            inc=1\n            \n\n            # assign weight ids according to the partition\n            deepdive db assign_sequential_id 'dd_weights_inf_istrue_is_target' id $baseId $inc\n\n            \n        "
        },
        "process/grounding/factor/inf_istrue_is_target/dump": {
          "dependencies_": [
            "process/grounding/factor/inf_istrue_is_target/assign_weight_id"
          ],
          "style": "cmd_extractor",
          "cmd": "\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n            facPath=\"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_is_target'\n            mkdir -p \"$facPath\"\n            cd \"$facPath\"\n            find . \\( -name  'factors.part-*.bin.bz2' \\\n                    -o -name 'nfactors.part-*'         \\\n                    -o -name   'nedges.part-*'         \\\n                   \\) -exec rm -rf {} +\n            export DEEPDIVE_LOAD_FORMAT=tsv\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n            # dump the factors joining the assigned weight ids, converting into binary format for the inference engine\n            deepdive compute execute \\\n                input_sql='SELECT \"weights\".\"id\" AS \"weight_id\"\n     , \"factors\".\"is_target.R0.id\"\nFROM \"dd_factors_inf_istrue_is_target\" \"factors\", \"dd_weights_inf_istrue_is_target\" \"weights\"\n\nWHERE \"factors\".\"dd_weight_column_0\" = \"weights\".\"dd_weight_column_0\"' \\\n                command='\n                    # also record the factor count\n                    tee >(wc -l >nfactors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}) |\n                    format_converter factor /dev/stdin >(pbzip2 >factors.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2) 0 1 original 1 |\n                    # and the edge count\n                    tee nedges.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}\n                ' \\\n                output_relation=\n        "
        },
        "process/grounding/factor/inf_istrue_is_target/dump_weights": {
          "dependencies_": [
            "process/grounding/factor/inf_istrue_is_target/assign_weight_id"
          ],
          "style": "cmd_extractor",
          "cmd": "\n            : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n            facPath=\"$DEEPDIVE_GROUNDING_DIR\"/factor/'inf_istrue_is_target'\n            mkdir -p \"$facPath\"\n            cd \"$facPath\"\n            find . \\( -name  'weights.part-*.bin.bz2' \\\n                   \\) -exec rm -rf {} +\n            export DEEPDIVE_LOAD_FORMAT=tsv\n            export DEEPDIVE_UNLOAD_MATERIALIZED=false\n\n            # flag that signals whether to reuse weights or not\n            reuseFlag=\"$DEEPDIVE_GROUNDING_DIR\"/factor/weights.reuse\n\n            # dump the weights (except the description column), converting into binary format for the inference engine\n            deepdive compute execute \\\n                input_sql=\"$(if [[ -e \"$reuseFlag\" ]]; then\n                    echo 'SELECT \"w\".\"id\"\n     , CASE WHEN w.isfixed THEN 1 ELSE 0 END\n     , COALESCE(reuse.weight, w.initvalue, 0)\nFROM \"dd_weights_inf_istrue_is_target\" \"w\"\nLEFT OUTER JOIN \"dd_graph_weights_reuse\" \"reuse\" ON \"reuse\".\"description\" = '\\''inf_istrue_is_target-'\\'' ||'\\''-'\\''|| CASE WHEN \"dd_weight_column_0\" IS NULL THEN '\\'''\\''\n              ELSE \"dd_weight_column_0\" || '\\'''\\''  -- XXX CAST(... AS TEXT) unsupported by MySQL\n          END'\n                else\n                    echo 'SELECT \"id\"\n     , CASE WHEN isfixed THEN 1 ELSE 0 END\n     , COALESCE(initvalue, 0)\nFROM \"dd_weights_inf_istrue_is_target\"'\n                fi)\" \\\n                command='\n                    format_converter weight /dev/stdin >(pbzip2 >weights.part-${DEEPDIVE_CURRENT_PROCESS_INDEX}.bin.bz2)\n                ' \\\n                output_relation=\n        "
        },
        "process/grounding/combine_factorgraph": {
          "dependencies_": [
            "process/grounding/variable/is_target/dump",
            "process/grounding/factor/inf_istrue_is_target/dump",
            "process/grounding/factor/inf_istrue_is_target/dump_weights",
            "process/grounding/global_weight_table"
          ],
          "output_": "model/factorgraph",
          "style": "cmd_extractor",
          "cmd": "\n        : ${DEEPDIVE_GROUNDING_DIR:=\"$DEEPDIVE_APP\"/run/model/grounding}\n        : ${DEEPDIVE_FACTORGRAPH_DIR:=\"$DEEPDIVE_APP\"/run/model/factorgraph}\n\n        # create a fresh empty directory for the new combined factor graph\n        rm -rf   \"$DEEPDIVE_FACTORGRAPH_DIR\"\n        mkdir -p \"$DEEPDIVE_FACTORGRAPH_DIR\"\n        cd \"$DEEPDIVE_FACTORGRAPH_DIR\"\n\n        # create symlinks to the grounded binaries by enumerating variables and factors\n        for v in 'is_target'; do\n            mkdir -p variables/\"$v\"\n            find \"$DEEPDIVE_GROUNDING_DIR\"/variable/\"$v\" \\\n                -name 'variables.part-*.bin.bz2' -exec ln -sfnv -t variables/\"$v\"/ {} + \\\n                #\n        done\n        for f in 'inf_istrue_is_target'; do\n            mkdir -p {factors,weights}/\"$f\"\n            find \"$DEEPDIVE_GROUNDING_DIR\"/factor/\"$f\" \\\n                -name 'factors.part-*.bin.bz2' -exec ln -sfnv -t factors/\"$f\"/ {} + \\\n                -o \\\n                -name 'weights.part-*.bin.bz2' -exec ln -sfnv -t weights/\"$f\"/ {} + \\\n                #\n        done\n\n        # generate the metadata for the inference engine\n        {\n            # first line with counts of variables and edges in the grounded factor graph\n            cd \"$DEEPDIVE_GROUNDING_DIR\"\n            sumup() { { tr '\\n' +; echo 0; } | bc; }\n            counts=()\n            counts+=($(cat factor/weights_count))\n            # sum up the number of factors and edges\n            counts+=($(cat variable_count))\n            cd factor\n            counts+=($(find 'inf_istrue_is_target' -name 'nfactors.part-*' -exec cat {} + | sumup))\n            counts+=($(find 'inf_istrue_is_target' -name 'nedges.part-*'   -exec cat {} + | sumup))\n            (IFS=,; echo \"${counts[*]}\")\n            # second line with file paths\n            paths=(\"$DEEPDIVE_FACTORGRAPH_DIR\"/{weights,variables,factors,edges})\n            (IFS=,; echo \"${paths[*]}\")\n        } >meta\n        "
        },
        "process/model/learning": {
          "dependencies_": [
            "model/factorgraph"
          ],
          "output_": "model/weights",
          "style": "cmd_extractor",
          "cmd": "mkdir -p ../../../model && cd ../../../model\n            mkdir -p weights\n            [ -d factorgraph ] || error \"No factorgraph found\"\n            # run inference engine for learning and inference\n            flatten() { find -L \"$@\" -type f -exec pbzip2 -c -d -k {} +; }\n            sampler-dw \\\n                gibbs \\\n                -w <(flatten factorgraph/weights) \\\n                -v <(flatten factorgraph/variables) \\\n                -f <(flatten factorgraph/factors) \\\n                -m factorgraph/meta \\\n                -o weights \\\n                -l 1000 -s 1 -i 1000 --alpha 0.01 --sample_evidence\n            mkdir -p probabilities\n            mv -f weights/inference_result.out.text probabilities/\n        "
        },
        "process/model/inference": {
          "dependencies_": [
            "model/factorgraph",
            "model/weights"
          ],
          "output_": "model/probabilities",
          "style": "cmd_extractor",
          "cmd": "mkdir -p ../../../model && cd ../../../model\n            [ -d factorgraph ] || error \"No factorgraph found\"\n            if [[ factorgraph/weights -nt probabilities/inference_result.out.text ]]; then\n                # no need to run inference unless the weights are fresher\n                # XXX this skipping may cause confusion\n                # run sampler for performing inference with given weights without learning\n                flatten() { find -L \"$@\" -type f -exec pbzip2 -c -d -k {} +; }\n                sampler-dw \\\n                    gibbs \\\n                    -w <(flatten factorgraph/weights) \\\n                    -v <(flatten factorgraph/variables) \\\n                    -f <(flatten factorgraph/factors) \\\n                    -m factorgraph/meta \\\n                    -o weights \\\n                    -l 1000 -s 1 -i 1000 --alpha 0.01 --sample_evidence \\\n                    -l 0 \\\n                    #\n                mkdir -p probabilities\n                mv -f weights/inference_result.out.text probabilities/\n            fi\n        "
        },
        "process/model/load_weights": {
          "dependencies_": [
            "model/weights"
          ],
          "output_": "data/model/weights",
          "style": "cmd_extractor",
          "cmd": "mkdir -p ../../../model && cd ../../../model\n            # load weights to database\n            deepdive create table dd_inference_result_weights \\\n                id:BIGINT:'PRIMARY KEY' \\\n                weight:'DOUBLE PRECISION' \\\n                #\n            cat weights/inference_result.out.weights.text |\n            tr ' ' '\\t' | DEEPDIVE_LOAD_FORMAT=tsv \\\n            deepdive load dd_inference_result_weights /dev/stdin\n\n            # create views\n            deepdive create view dd_inference_result_weights_mapping as '\n                SELECT dd_graph_weights.*, dd_inference_result_weights.weight FROM\n                dd_graph_weights JOIN dd_inference_result_weights ON dd_graph_weights.id = dd_inference_result_weights.id\n                ORDER BY abs(weight) DESC\n            '\n\n            deepdive create view dd_inference_result_variables_mapped_weights as '\n                SELECT * FROM dd_inference_result_weights_mapping\n                ORDER BY abs(weight) DESC\n            '\n        "
        },
        "process/model/load_probabilities": {
          "dependencies_": [
            "model/probabilities"
          ],
          "output_": "data/model/probabilities",
          "style": "cmd_extractor",
          "cmd": "mkdir -p ../../../model && cd ../../../model\n            # load weights to database\n            deepdive create table dd_inference_result_variables \\\n                id:BIGINT \\\n                category:BIGINT \\\n                expectation:'DOUBLE PRECISION' \\\n                #\n            cat probabilities/inference_result.out.text |\n            tr ' ' '\\t' | DEEPDIVE_LOAD_FORMAT=tsv \\\n            deepdive load dd_inference_result_variables /dev/stdin\n\n            # create a view for each app schema variable\n            \n            deepdive create view 'is_target_label_inference' as '\n                SELECT is_target.*, mir.category, mir.expectation FROM\n                is_target, dd_inference_result_variables mir\n                WHERE is_target.id = mir.id\n                ORDER BY mir.expectation DESC\n                '\n        "
        },
        "process/model/calibration": {
          "dependencies_": [
            "data/model/probabilities",
            "process/model/load_probabilities"
          ],
          "output_": "model/calibration-plots",
          "style": "cmd_extractor",
          "cmd": "\n            d=../../../model/calibration-plots && mkdir -p \"$d\" && cd \"$d\"\n            # XXX a legacy location under the current run directory for backward compatibility\n            extraOutput=\"${DEEPDIVE_OUTPUT:-../../RUNNING}\"/calibration && mkdir -p \"$extraOutput\"\n            DEEPDIVE_CALIBRATION_NUM_BUCKETS=10\n            \n            # create a view and draw a calibration plot for variable null\n            deepdive db create_calibration_view 'is_target' 'label'\n            draw_calibration_plot      'is_target' 'label'\n            # XXX keeping a duplicate copy under the current run directory for backward compatibility\n            cp -a 'is_target_label'.* \"$extraOutput\"/\n            \n        "
        }
      },
      "dependencies": {
        "process/init/app": [],
        "process/init/relation/articles": [
          "process/init/app"
        ],
        "process/init/relation/targets_chemcam_mer": [
          "process/init/app"
        ],
        "process/ext_is_target": [
          "data/target_label_resolved",
          "data/target_mention"
        ],
        "process/ext_person_mention_by_map_person_mention": [
          "data/sentences"
        ],
        "process/ext_sentences_by_nlp_markup": [
          "data/articles"
        ],
        "process/ext_target_feature_by_extract_target_features": [
          "data/sentences",
          "data/target_mention"
        ],
        "process/ext_target_label": [
          "data/target_label__0",
          "data/target_mention",
          "data/targets_chemcam_mer"
        ],
        "process/ext_target_label__0_by_supervise": [
          "data/sentences",
          "data/target_mention"
        ],
        "process/ext_target_label_resolved": [
          "data/target_label"
        ],
        "process/ext_target_mention_by_map_target_mention": [
          "data/sentences"
        ],
        "process/grounding/variable_id_partition": [
          "data/is_target"
        ],
        "process/grounding/variable/is_target/assign_id": [
          "process/grounding/variable_id_partition"
        ],
        "process/grounding/variable_holdout": [
          "process/grounding/variable/is_target/assign_id"
        ],
        "process/grounding/variable/is_target/dump": [
          "process/grounding/variable_holdout"
        ],
        "process/grounding/factor/inf_istrue_is_target/materialize": [
          "data/target_feature",
          "data/target_mention",
          "process/grounding/variable/is_target/assign_id"
        ],
        "process/grounding/weight_id_partition": [
          "process/grounding/factor/inf_istrue_is_target/materialize"
        ],
        "process/grounding/global_weight_table": [
          "process/grounding/factor/inf_istrue_is_target/materialize"
        ],
        "process/grounding/factor/inf_istrue_is_target/assign_weight_id": [
          "process/grounding/weight_id_partition"
        ],
        "process/grounding/factor/inf_istrue_is_target/dump": [
          "process/grounding/factor/inf_istrue_is_target/assign_weight_id"
        ],
        "process/grounding/factor/inf_istrue_is_target/dump_weights": [
          "process/grounding/factor/inf_istrue_is_target/assign_weight_id"
        ],
        "process/grounding/combine_factorgraph": [
          "process/grounding/factor/inf_istrue_is_target/dump",
          "process/grounding/factor/inf_istrue_is_target/dump_weights",
          "process/grounding/global_weight_table",
          "process/grounding/variable/is_target/dump"
        ],
        "process/model/learning": [
          "model/factorgraph"
        ],
        "process/model/inference": [
          "model/factorgraph",
          "model/weights"
        ],
        "process/model/load_weights": [
          "model/weights"
        ],
        "process/model/load_probabilities": [
          "model/probabilities"
        ],
        "process/model/calibration": [
          "data/model/probabilities"
        ],
        "data/articles": [
          "process/init/relation/articles"
        ],
        "data/is_target": [
          "process/ext_is_target"
        ],
        "data/model/probabilities": [
          "process/model/load_probabilities"
        ],
        "data/model/weights": [
          "process/model/load_weights"
        ],
        "data/person_mention": [
          "process/ext_person_mention_by_map_person_mention"
        ],
        "data/sentences": [
          "process/ext_sentences_by_nlp_markup"
        ],
        "data/target_feature": [
          "process/ext_target_feature_by_extract_target_features"
        ],
        "data/target_label": [
          "process/ext_target_label"
        ],
        "data/target_label__0": [
          "process/ext_target_label__0_by_supervise"
        ],
        "data/target_label_resolved": [
          "process/ext_target_label_resolved"
        ],
        "data/target_mention": [
          "process/ext_target_mention_by_map_target_mention"
        ],
        "data/targets_chemcam_mer": [
          "process/init/relation/targets_chemcam_mer"
        ],
        "model/calibration-plots": [
          "process/model/calibration"
        ],
        "model/factorgraph": [
          "process/grounding/combine_factorgraph"
        ],
        "model/probabilities": [
          "process/model/inference"
        ],
        "model/weights": [
          "process/model/learning"
        ]
      }
    }
  }
}
